{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACAA;AACA,WAFA,MAGA;AACA;AACA;AACA;;AACA;AACA,OAVA;AAYA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,yCAAqCC,oBAArC,EAA2DA,GAA3D,EAA2D;AAC3D,8CAA4CC,uBAA5C,EAAqEA,GAArE,EAAqE;AACrE,2DACA;AACA;AACA;;AACA;AACA,OAbA;AAeA;AACA;AACA;;;AACA;AACA;;AACA,wCAAoCC,eAApC,EAAqDA,KAArD,EAAqD;AACrD;AACA;AACA;AACA;;AACA;AACA,OARA;AAUA;AACA;AACA;;;AACA;AACA;;AACA,2CAAuCC,kBAAvC,EAA2DA,QAA3D,EAA2D;AAC3D;AACA;AACA;AACA;;AACA;AACA,OARA;AAUA;AACA;AACA;;;AACA;AACA,4DACAC,+CADA,IAEAC,0DAFA;AAGA,OAJA;AAMA;AACA;AACA;;;AACA;AACA,wCAAoCH,eAApC,EAAqDA,KAArD,EAAqD;AACrD,6CAA2CC,kBAA3C,EAA+DA,QAA/D,EAA+D;AAC/D;AACA,2CAA6CG,cAA7C,EAA6DA,GAA7D,EAA6D;AAC7DC;;AACA;AACA;AACA;;AACAA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA,OAhBA;AAkBA;AACA;AACA;;;AACA;AACA,oCACAC,IADA,CACA,CADA,EAEAC,GAFA,CAEA;AAAA;AAAA,SAFA;AAGA,OAJA;AAMA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACAC;AACAA;AACAA;AACA;AACA;AACA;;;iBACA;AACAA;AACAA;AACAA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;;;;UAEAC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","names":["constraint","r","c","row","column","checkColumnConstraint","checkBoxConstraint","k","board","fill","map","DancingNode","node","ColumnNode","i","j","DLX","columnNodes","headerNode","grid","prev","col","min","ret","answer","tmp","rcNode","result","n","rowDelta","columnDelta","matrix","coverBoard","header","createBoxConstraints","num","dlx","solve","results","indexMap","sort","selectBoard"],"sources":["webpack:///node_modules/@donmahallem/sudoku/dist/esm/index.js"],"sourcesContent":["/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst COVER_START_IDX = 1;\r\nconst BOARD_START_IDX = 0;\r\nconst CONSTRAINTS = 4;\r\nconst EMPTY_CELL = 0;\r\nconst CELL_VALUE_MIN = 1;\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst checkConstraint = (board, row, constraint, column) => {\r\n    if (board[row][column] !== EMPTY_CELL) {\r\n        if (!constraint[board[row][column] - 1]) {\r\n            constraint[board[row][column] - 1] = true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst checkBoxConstraint = (board, row, column, boardSize, boxSize) => {\r\n    const constraint = new Array(boardSize).fill(false);\r\n    const subsectionRowStart = Math.floor(row / boxSize) * boxSize;\r\n    const subsectionRowEnd = subsectionRowStart + boxSize;\r\n    const subsectionColumnStart = Math.floor(column / boxSize) * boxSize;\r\n    const subsectionColumnEnd = subsectionColumnStart + boxSize;\r\n    for (let r = subsectionRowStart; r < subsectionRowEnd; r++) {\r\n        for (let c = subsectionColumnStart; c < subsectionColumnEnd; c++) {\r\n            if (!checkConstraint(board, r, constraint, c))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst checkColumnConstraint = (board, column, boardSize) => {\r\n    const constraint = new Array(boardSize).fill(false);\r\n    for (let row = BOARD_START_IDX; row < boardSize; row++) {\r\n        if (!checkConstraint(board, row, constraint, column)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst checkRowConstraint = (board, row, boardSize) => {\r\n    const constraint = new Array(boardSize).fill(false);\r\n    for (let column = BOARD_START_IDX; column < boardSize; column++) {\r\n        if (!checkConstraint(board, row, constraint, column)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst isValid = (board, row, column, boardSize, boxSize) => {\r\n    return checkRowConstraint(board, row, boardSize) &&\r\n        checkColumnConstraint(board, column, boardSize) &&\r\n        checkBoxConstraint(board, row, column, boardSize, boxSize);\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst solve$1 = (board, boardSize, boxSize) => {\r\n    for (let row = BOARD_START_IDX; row < boardSize; row++) {\r\n        for (let column = BOARD_START_IDX; column < boardSize; column++) {\r\n            if (board[row][column] === EMPTY_CELL) {\r\n                for (let k = CELL_VALUE_MIN; k <= boardSize; k++) {\r\n                    board[row][column] = k;\r\n                    if (isValid(board, row, column, boardSize, boxSize) && solve$1(board, boardSize, boxSize)) {\r\n                        return true;\r\n                    }\r\n                    board[row][column] = EMPTY_CELL;\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst createEmptySudokuBoard = (boardSize) => {\r\n    return new Array(boardSize)\r\n        .fill(0)\r\n        .map(() => new Array(boardSize).fill(EMPTY_CELL));\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\n// tslint:disable:max-classes-per-file\r\nclass DancingNode {\r\n    constructor(columnNode) {\r\n        this.left = this;\r\n        this.right = this;\r\n        this.top = this;\r\n        this.bottom = this;\r\n        this.column = columnNode;\r\n    }\r\n    linkDown(node) {\r\n        node.bottom = this.bottom;\r\n        node.bottom.top = node;\r\n        node.top = this;\r\n        this.bottom = node;\r\n        return node;\r\n    }\r\n    linkRight(node) {\r\n        node.right = this.right;\r\n        node.right.left = node;\r\n        node.left = this;\r\n        this.right = node;\r\n        return node;\r\n    }\r\n    removeLeftRight() {\r\n        this.left.right = this.right;\r\n        this.right.left = this.left;\r\n    }\r\n    reinsertLeftRight() {\r\n        this.left.right = this;\r\n        this.right.left = this;\r\n    }\r\n    removeTopBottom() {\r\n        this.top.bottom = this.bottom;\r\n        this.bottom.top = this.top;\r\n    }\r\n    reinsertTopBottom() {\r\n        this.top.bottom = this;\r\n        this.bottom.top = this;\r\n    }\r\n}\r\nclass ColumnNode extends DancingNode {\r\n    constructor(name) {\r\n        super();\r\n        this.name = name;\r\n        this.size = 0;\r\n        this.column = this;\r\n    }\r\n    cover() {\r\n        this.removeLeftRight();\r\n        for (let i = this.bottom; i !== this; i = i.bottom) {\r\n            for (let j = i.right; j !== i; j = j.right) {\r\n                j.removeTopBottom();\r\n                j.column.size--;\r\n            }\r\n        }\r\n    }\r\n    uncover() {\r\n        for (let i = this.top; i !== this; i = i.top) {\r\n            for (let j = i.left; j !== i; j = j.left) {\r\n                j.column.size++;\r\n                j.reinsertTopBottom();\r\n            }\r\n        }\r\n        this.reinsertLeftRight();\r\n    }\r\n}\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nclass DLX {\r\n    constructor(cover, boardSize) {\r\n        this.boardSize = boardSize;\r\n        this.isDone = false;\r\n        this.header = this.createDLXList(cover);\r\n    }\r\n    createDLXList(grid) {\r\n        const nbColumns = grid[0].length;\r\n        let headerNode = new ColumnNode('header');\r\n        const columnNodes = [];\r\n        for (let i = 0; i < nbColumns; i++) {\r\n            const n = new ColumnNode(`${i}`);\r\n            columnNodes.push(n);\r\n            headerNode = headerNode.linkRight(n);\r\n        }\r\n        headerNode = headerNode.right.column;\r\n        for (const aGrid of grid) {\r\n            let prev = undefined;\r\n            for (let j = 0; j < nbColumns; j++) {\r\n                if (aGrid[j]) {\r\n                    const col = columnNodes[j];\r\n                    const newNode = new DancingNode(col);\r\n                    // tslint:disable-next-line:triple-equals\r\n                    if (prev == undefined) {\r\n                        prev = newNode;\r\n                    }\r\n                    col.top.linkDown(newNode);\r\n                    prev = prev.linkRight(newNode);\r\n                    col.size++;\r\n                }\r\n            }\r\n        }\r\n        headerNode.size = nbColumns;\r\n        return headerNode;\r\n    }\r\n    selectColumnNodeHeuristic() {\r\n        let min = Number.MAX_VALUE;\r\n        // tslint:disable-next-line:no-unnecessary-initializer\r\n        let ret = undefined;\r\n        for (let c = this.header.right; c !== this.header; c = c.right) {\r\n            if (c.size < min) {\r\n                min = c.size;\r\n                ret = c;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    handleSolution(anser) {\r\n        const field = this.parseSolution(anser);\r\n        this.isDone = this.resultCallback(field);\r\n    }\r\n    parseSolution(answer) {\r\n        const result = createEmptySudokuBoard(this.boardSize);\r\n        for (const n of answer) {\r\n            let rcNode = n;\r\n            let min = parseInt(rcNode.column.name, 10);\r\n            for (let tmp = n.right; tmp !== n; tmp = tmp.right) {\r\n                const val = parseInt(tmp.column.name, 10);\r\n                if (val < min) {\r\n                    min = val;\r\n                    rcNode = tmp;\r\n                }\r\n            }\r\n            const ans1 = parseInt(rcNode.column.name, 10);\r\n            const ans2 = parseInt(rcNode.right.column.name, 10);\r\n            const r = Math.floor(ans1 / this.boardSize);\r\n            const c = ans1 % this.boardSize;\r\n            const num = (ans2 % this.boardSize) + 1;\r\n            result[r][c] = num;\r\n        }\r\n        return result;\r\n    }\r\n    search(k) {\r\n        if (this.isDone) {\r\n            return;\r\n        }\r\n        if (this.header.right === this.header) {\r\n            this.handleSolution(this.answer);\r\n        }\r\n        else {\r\n            let c = this.selectColumnNodeHeuristic();\r\n            c.cover();\r\n            for (let r = c.bottom; r !== c; r = r.bottom) {\r\n                this.answer.push(r);\r\n                for (let j = r.right; j !== r; j = j.right) {\r\n                    j.column.cover();\r\n                }\r\n                this.search(k + 1);\r\n                r = this.answer.splice(this.answer.length - 1, 1)[0];\r\n                c = r.column;\r\n                for (let j = r.left; j !== r; j = j.left) {\r\n                    j.column.uncover();\r\n                }\r\n            }\r\n            c.uncover();\r\n        }\r\n    }\r\n    runSolver(cb) {\r\n        this.answer = [];\r\n        this.isDone = false;\r\n        this.resultCallback = cb;\r\n        this.search(0);\r\n    }\r\n}\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst getIndex = (row, column, num, boardSize) => {\r\n    return (row - 1) * boardSize * boardSize + (column - 1) * boardSize + (num - 1);\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst createBoxConstraints = (matrix, header, boardSize, boxSize) => {\r\n    let headerIter = header;\r\n    for (let row = COVER_START_IDX; row <= boardSize; row += boxSize) {\r\n        for (let column = COVER_START_IDX; column <= boardSize; column += boxSize) {\r\n            for (let n = COVER_START_IDX; n <= boardSize; n++, headerIter++) {\r\n                for (let rowDelta = 0; rowDelta < boxSize; rowDelta++) {\r\n                    for (let columnDelta = 0; columnDelta < boxSize; columnDelta++) {\r\n                        const index = getIndex(row + rowDelta, column + columnDelta, n, boardSize);\r\n                        matrix[index][headerIter] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return headerIter;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst createCellConstraints = (matrix, header, boardSize) => {\r\n    let headerIter = header;\r\n    for (let row = COVER_START_IDX; row <= boardSize; row++) {\r\n        for (let column = COVER_START_IDX; column <= boardSize; column++, headerIter++) {\r\n            for (let n = COVER_START_IDX; n <= boardSize; n++) {\r\n                const index = getIndex(row, column, n, boardSize);\r\n                // console.log(index, _header, matrix.length);\r\n                matrix[index][headerIter] = true;\r\n            }\r\n        }\r\n    }\r\n    return headerIter;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst createColumnConstraints = (matrix, header, boardSize) => {\r\n    let iterHeader = header;\r\n    for (let column = COVER_START_IDX; column <= boardSize; column++) {\r\n        for (let n = COVER_START_IDX; n <= boardSize; n++, iterHeader++) {\r\n            for (let row = COVER_START_IDX; row <= boardSize; row++) {\r\n                const index = getIndex(row, column, n, boardSize);\r\n                matrix[index][iterHeader] = true;\r\n            }\r\n        }\r\n    }\r\n    return iterHeader;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst createRowConstraints = (coverBoard, hBase, boardSize) => {\r\n    let headerIter = hBase;\r\n    for (let row = COVER_START_IDX; row <= boardSize; row++) {\r\n        for (let n = COVER_START_IDX; n <= boardSize; n++, headerIter++) {\r\n            for (let column = COVER_START_IDX; column <= boardSize; column++) {\r\n                const index = getIndex(row, column, n, boardSize);\r\n                coverBoard[index][headerIter] = true;\r\n            }\r\n        }\r\n    }\r\n    return headerIter;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst createCoverMatrix = (boardSize, boxSize) => {\r\n    const coverMatrix = new Array(boardSize * boardSize * boardSize)\r\n        .fill([])\r\n        .map(() => new Array(boardSize * boardSize * CONSTRAINTS).fill(false));\r\n    let header = 0;\r\n    header = createCellConstraints(coverMatrix, header, boardSize);\r\n    header = createRowConstraints(coverMatrix, header, boardSize);\r\n    header = createColumnConstraints(coverMatrix, header, boardSize);\r\n    createBoxConstraints(coverMatrix, header, boardSize, boxSize);\r\n    return coverMatrix;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst initializeExactCoverBoard = (board, boardSize, boxSize) => {\r\n    const coverBoard = createCoverMatrix(boardSize, boxSize);\r\n    for (let row = COVER_START_IDX; row <= boardSize; row++) {\r\n        for (let column = COVER_START_IDX; column <= boardSize; column++) {\r\n            const n = board[row - 1][column - 1];\r\n            if (n !== EMPTY_CELL) {\r\n                for (let num = CELL_VALUE_MIN; num <= boardSize; num++) {\r\n                    if (num !== n) {\r\n                        coverBoard[getIndex(row, column, num, boardSize)].fill(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return coverBoard;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst solve = (board, boardSize, boxSize, cb) => {\r\n    const cover = initializeExactCoverBoard(board, boardSize, boxSize);\r\n    const dlx = new DLX(cover, boardSize);\r\n    dlx.runSolver(cb);\r\n};\r\nconst solveNum = (board, boardSize, boxSize, num) => {\r\n    const results = [];\r\n    solve(board, boardSize, boxSize, (result) => {\r\n        results.push(result);\r\n        return results.length >= num;\r\n    });\r\n    return results;\r\n};\n\n/**!\r\n * Source https://github.com/donmahallem/js-libs Package: sudoku\r\n */\r\nconst indexMap = {};\r\nconst getIndexMap = (boardSize) => {\r\n    if (!(boardSize in indexMap)) {\r\n        indexMap[boardSize] = new Array(boardSize ** 2).fill(0).map((val, idx) => idx);\r\n    }\r\n    return indexMap[boardSize];\r\n};\r\nconst createSudokuBoard = (boardSize, retainPercentage) => {\r\n    const board = createEmptySudokuBoard(boardSize);\r\n    const boxSize = Math.sqrt(boardSize);\r\n    const randomNumbers = new Array(boardSize).fill(0).map((val, idx) => idx + 1)\r\n        .sort(() => Math.random() - 0.5);\r\n    for (let i = 0; i < boardSize; i++) {\r\n        board[i][Math.floor(Math.random() * boardSize)] = randomNumbers[i];\r\n    }\r\n    const selectBoard = solveNum(board, boardSize, boxSize, 1)[0];\r\n    const removeIndexes = getIndexMap(boardSize)\r\n        .sort(() => Math.random() - 0.5);\r\n    for (let i = 0; i <= Math.floor(removeIndexes.length * retainPercentage); i++) {\r\n        const removeX = removeIndexes[i] % boardSize;\r\n        const removeY = Math.floor(removeIndexes[i] / boardSize);\r\n        selectBoard[removeX][removeY] = 0;\r\n    }\r\n    return selectBoard;\r\n};\n\nexport { solve$1 as backtrackSolve, createEmptySudokuBoard, createSudokuBoard, solve as knuthSolve, solveNum as knuthSolveNum };\n// BUILD: Tue Jun 29 2021 20:35:46 GMT+0200 (Central European Summer Time)\n\n//# sourceMappingURL=index.js.map\n"]}