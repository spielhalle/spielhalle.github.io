{"version":3,"sources":["webpack/bootstrap","./node_modules/@donmahallem/sudoku/dist/esm/index.js","./src/app/routes/sudoku/services/sudoku-solver.worker.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D,2CAA2C,yBAAyB;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD,0CAA0C,oBAAoB;AAC9D;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,0CAA0C,qBAAqB;AAC/D,yCAAyC,gBAAgB;AACzD,sCAAsC,oBAAoB;AAC1D,6CAA6C,uBAAuB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,0CAA0C,qBAAqB;AAC/D,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D,qCAAqC,gBAAgB;AACrD,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,qCAAqC,gBAAgB;AACrD,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,0CAA0C,qBAAqB;AAC/D;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAA0D;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEgI;AAChI;;AAEA;;;;;;;;;;;;;AC7bA;AAAA;AAAA;;GAEG;AACH,iCAAiC;AACmB;AACpD,gBAAgB,CAAC,SAAS,EAAE,CAAC,GAAiB,EAAQ,EAAE;IACpD,MAAM,OAAO,GAAiB,yEAAa,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;IAChE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;AAC9B,CAAC,CAAC,CAAC","file":"solveSudokuWorker-es2015.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"ZwK9\");\n","/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst COVER_START_IDX = 1;\nconst BOARD_START_IDX = 0;\nconst CONSTRAINTS = 4;\nconst EMPTY_CELL = 0;\nconst CELL_VALUE_MIN = 1;\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst checkConstraint = (board, row, constraint, column) => {\n    if (board[row][column] !== EMPTY_CELL) {\n        if (!constraint[board[row][column] - 1]) {\n            constraint[board[row][column] - 1] = true;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst checkBoxConstraint = (board, row, column, boardSize, boxSize) => {\n    const constraint = new Array(boardSize).fill(false);\n    const subsectionRowStart = Math.floor(row / boxSize) * boxSize;\n    const subsectionRowEnd = subsectionRowStart + boxSize;\n    const subsectionColumnStart = Math.floor(column / boxSize) * boxSize;\n    const subsectionColumnEnd = subsectionColumnStart + boxSize;\n    for (let r = subsectionRowStart; r < subsectionRowEnd; r++) {\n        for (let c = subsectionColumnStart; c < subsectionColumnEnd; c++) {\n            if (!checkConstraint(board, r, constraint, c))\n                return false;\n        }\n    }\n    return true;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst checkColumnConstraint = (board, column, boardSize) => {\n    const constraint = new Array(boardSize).fill(false);\n    for (let row = BOARD_START_IDX; row < boardSize; row++) {\n        if (!checkConstraint(board, row, constraint, column)) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst checkRowConstraint = (board, row, boardSize) => {\n    const constraint = new Array(boardSize).fill(false);\n    for (let column = BOARD_START_IDX; column < boardSize; column++) {\n        if (!checkConstraint(board, row, constraint, column)) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst isValid = (board, row, column, boardSize, boxSize) => {\n    return checkRowConstraint(board, row, boardSize) &&\n        checkColumnConstraint(board, column, boardSize) &&\n        checkBoxConstraint(board, row, column, boardSize, boxSize);\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst solve$1 = (board, boardSize, boxSize) => {\n    for (let row = BOARD_START_IDX; row < boardSize; row++) {\n        for (let column = BOARD_START_IDX; column < boardSize; column++) {\n            if (board[row][column] === EMPTY_CELL) {\n                for (let k = CELL_VALUE_MIN; k <= boardSize; k++) {\n                    board[row][column] = k;\n                    if (isValid(board, row, column, boardSize, boxSize) && solve$1(board, boardSize, boxSize)) {\n                        return true;\n                    }\n                    board[row][column] = EMPTY_CELL;\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst createEmptySudokuBoard = (boardSize) => {\n    return new Array(boardSize)\n        .fill(0)\n        .map(() => new Array(boardSize).fill(EMPTY_CELL));\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\n// tslint:disable:max-classes-per-file\nclass DancingNode {\n    constructor(columnNode) {\n        this.left = this;\n        this.right = this;\n        this.top = this;\n        this.bottom = this;\n        this.column = columnNode;\n    }\n    linkDown(node) {\n        node.bottom = this.bottom;\n        node.bottom.top = node;\n        node.top = this;\n        this.bottom = node;\n        return node;\n    }\n    linkRight(node) {\n        node.right = this.right;\n        node.right.left = node;\n        node.left = this;\n        this.right = node;\n        return node;\n    }\n    removeLeftRight() {\n        this.left.right = this.right;\n        this.right.left = this.left;\n    }\n    reinsertLeftRight() {\n        this.left.right = this;\n        this.right.left = this;\n    }\n    removeTopBottom() {\n        this.top.bottom = this.bottom;\n        this.bottom.top = this.top;\n    }\n    reinsertTopBottom() {\n        this.top.bottom = this;\n        this.bottom.top = this;\n    }\n}\nclass ColumnNode extends DancingNode {\n    constructor(name) {\n        super();\n        this.name = name;\n        this.size = 0;\n        this.column = this;\n    }\n    cover() {\n        this.removeLeftRight();\n        for (let i = this.bottom; i !== this; i = i.bottom) {\n            for (let j = i.right; j !== i; j = j.right) {\n                j.removeTopBottom();\n                j.column.size--;\n            }\n        }\n    }\n    uncover() {\n        for (let i = this.top; i !== this; i = i.top) {\n            for (let j = i.left; j !== i; j = j.left) {\n                j.column.size++;\n                j.reinsertTopBottom();\n            }\n        }\n        this.reinsertLeftRight();\n    }\n}\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nclass DLX {\n    constructor(cover, boardSize) {\n        this.boardSize = boardSize;\n        this.isDone = false;\n        this.header = this.createDLXList(cover);\n    }\n    createDLXList(grid) {\n        const nbColumns = grid[0].length;\n        let headerNode = new ColumnNode('header');\n        const columnNodes = [];\n        for (let i = 0; i < nbColumns; i++) {\n            const n = new ColumnNode(`${i}`);\n            columnNodes.push(n);\n            headerNode = headerNode.linkRight(n);\n        }\n        headerNode = headerNode.right.column;\n        for (const aGrid of grid) {\n            let prev = undefined;\n            for (let j = 0; j < nbColumns; j++) {\n                if (aGrid[j]) {\n                    const col = columnNodes[j];\n                    const newNode = new DancingNode(col);\n                    // tslint:disable-next-line:triple-equals\n                    if (prev == undefined) {\n                        prev = newNode;\n                    }\n                    col.top.linkDown(newNode);\n                    prev = prev.linkRight(newNode);\n                    col.size++;\n                }\n            }\n        }\n        headerNode.size = nbColumns;\n        return headerNode;\n    }\n    selectColumnNodeHeuristic() {\n        let min = Number.MAX_VALUE;\n        // tslint:disable-next-line:no-unnecessary-initializer\n        let ret = undefined;\n        for (let c = this.header.right; c !== this.header; c = c.right) {\n            if (c.size < min) {\n                min = c.size;\n                ret = c;\n            }\n        }\n        return ret;\n    }\n    handleSolution(anser) {\n        const field = this.parseSolution(anser);\n        this.isDone = this.resultCallback(field);\n    }\n    parseSolution(answer) {\n        const result = createEmptySudokuBoard(this.boardSize);\n        for (const n of answer) {\n            let rcNode = n;\n            let min = parseInt(rcNode.column.name, 10);\n            for (let tmp = n.right; tmp !== n; tmp = tmp.right) {\n                const val = parseInt(tmp.column.name, 10);\n                if (val < min) {\n                    min = val;\n                    rcNode = tmp;\n                }\n            }\n            const ans1 = parseInt(rcNode.column.name, 10);\n            const ans2 = parseInt(rcNode.right.column.name, 10);\n            const r = Math.floor(ans1 / this.boardSize);\n            const c = ans1 % this.boardSize;\n            const num = (ans2 % this.boardSize) + 1;\n            result[r][c] = num;\n        }\n        return result;\n    }\n    search(k) {\n        if (this.isDone) {\n            return;\n        }\n        if (this.header.right === this.header) {\n            this.handleSolution(this.answer);\n        }\n        else {\n            let c = this.selectColumnNodeHeuristic();\n            c.cover();\n            for (let r = c.bottom; r !== c; r = r.bottom) {\n                this.answer.push(r);\n                for (let j = r.right; j !== r; j = j.right) {\n                    j.column.cover();\n                }\n                this.search(k + 1);\n                r = this.answer.splice(this.answer.length - 1, 1)[0];\n                c = r.column;\n                for (let j = r.left; j !== r; j = j.left) {\n                    j.column.uncover();\n                }\n            }\n            c.uncover();\n        }\n    }\n    runSolver(cb) {\n        this.answer = [];\n        this.isDone = false;\n        this.resultCallback = cb;\n        this.search(0);\n    }\n}\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst getIndex = (row, column, num, boardSize) => {\n    return (row - 1) * boardSize * boardSize + (column - 1) * boardSize + (num - 1);\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst createBoxConstraints = (matrix, header, boardSize, boxSize) => {\n    let headerIter = header;\n    for (let row = COVER_START_IDX; row <= boardSize; row += boxSize) {\n        for (let column = COVER_START_IDX; column <= boardSize; column += boxSize) {\n            for (let n = COVER_START_IDX; n <= boardSize; n++, headerIter++) {\n                for (let rowDelta = 0; rowDelta < boxSize; rowDelta++) {\n                    for (let columnDelta = 0; columnDelta < boxSize; columnDelta++) {\n                        const index = getIndex(row + rowDelta, column + columnDelta, n, boardSize);\n                        matrix[index][headerIter] = true;\n                    }\n                }\n            }\n        }\n    }\n    return headerIter;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst createCellConstraints = (matrix, header, boardSize) => {\n    let headerIter = header;\n    for (let row = COVER_START_IDX; row <= boardSize; row++) {\n        for (let column = COVER_START_IDX; column <= boardSize; column++, headerIter++) {\n            for (let n = COVER_START_IDX; n <= boardSize; n++) {\n                const index = getIndex(row, column, n, boardSize);\n                // console.log(index, _header, matrix.length);\n                matrix[index][headerIter] = true;\n            }\n        }\n    }\n    return headerIter;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst createColumnConstraints = (matrix, header, boardSize) => {\n    let iterHeader = header;\n    for (let column = COVER_START_IDX; column <= boardSize; column++) {\n        for (let n = COVER_START_IDX; n <= boardSize; n++, iterHeader++) {\n            for (let row = COVER_START_IDX; row <= boardSize; row++) {\n                const index = getIndex(row, column, n, boardSize);\n                matrix[index][iterHeader] = true;\n            }\n        }\n    }\n    return iterHeader;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst createRowConstraints = (coverBoard, hBase, boardSize) => {\n    let headerIter = hBase;\n    for (let row = COVER_START_IDX; row <= boardSize; row++) {\n        for (let n = COVER_START_IDX; n <= boardSize; n++, headerIter++) {\n            for (let column = COVER_START_IDX; column <= boardSize; column++) {\n                const index = getIndex(row, column, n, boardSize);\n                coverBoard[index][headerIter] = true;\n            }\n        }\n    }\n    return headerIter;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst createCoverMatrix = (boardSize, boxSize) => {\n    const coverMatrix = new Array(boardSize * boardSize * boardSize)\n        .fill([])\n        .map(() => new Array(boardSize * boardSize * CONSTRAINTS).fill(false));\n    let header = 0;\n    header = createCellConstraints(coverMatrix, header, boardSize);\n    header = createRowConstraints(coverMatrix, header, boardSize);\n    header = createColumnConstraints(coverMatrix, header, boardSize);\n    createBoxConstraints(coverMatrix, header, boardSize, boxSize);\n    return coverMatrix;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst initializeExactCoverBoard = (board, boardSize, boxSize) => {\n    const coverBoard = createCoverMatrix(boardSize, boxSize);\n    for (let row = COVER_START_IDX; row <= boardSize; row++) {\n        for (let column = COVER_START_IDX; column <= boardSize; column++) {\n            const n = board[row - 1][column - 1];\n            if (n !== EMPTY_CELL) {\n                for (let num = CELL_VALUE_MIN; num <= boardSize; num++) {\n                    if (num !== n) {\n                        coverBoard[getIndex(row, column, num, boardSize)].fill(false);\n                    }\n                }\n            }\n        }\n    }\n    return coverBoard;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst solve = (board, boardSize, boxSize, cb) => {\n    const cover = initializeExactCoverBoard(board, boardSize, boxSize);\n    const dlx = new DLX(cover, boardSize);\n    dlx.runSolver(cb);\n};\nconst solveNum = (board, boardSize, boxSize, num) => {\n    const results = [];\n    solve(board, boardSize, boxSize, (result) => {\n        results.push(result);\n        return results.length >= num;\n    });\n    return results;\n};\n\n/**!\n * Source https://github.com/donmahallem/js-libs Package: sudoku\n */\nconst indexMap = {};\nconst getIndexMap = (boardSize) => {\n    if (!(boardSize in indexMap)) {\n        indexMap[boardSize] = new Array(boardSize ** 2).fill(0).map((val, idx) => idx);\n    }\n    return indexMap[boardSize];\n};\nconst createSudokuBoard = (boardSize, retainPercentage) => {\n    const board = createEmptySudokuBoard(boardSize);\n    const boxSize = Math.sqrt(boardSize);\n    const randomNumbers = new Array(boardSize).fill(0).map((val, idx) => idx + 1)\n        .sort(() => Math.random() - 0.5);\n    for (let i = 0; i < boardSize; i++) {\n        board[i][Math.floor(Math.random() * boardSize)] = randomNumbers[i];\n    }\n    const selectBoard = solveNum(board, boardSize, boxSize, 1)[0];\n    const removeIndexes = getIndexMap(boardSize)\n        .sort(() => Math.random() - 0.5);\n    for (let i = 0; i <= Math.floor(removeIndexes.length * retainPercentage); i++) {\n        const removeX = removeIndexes[i] % boardSize;\n        const removeY = Math.floor(removeIndexes[i] / boardSize);\n        selectBoard[removeX][removeY] = 0;\n    }\n    return selectBoard;\n};\n\nexport { solve$1 as backtrackSolve, createEmptySudokuBoard, createSudokuBoard, solve as knuthSolve, solveNum as knuthSolveNum };\n// BUILD: Mon Mar 22 2021 19:41:21 GMT+0000 (Coordinated Universal Time)\n\n//# sourceMappingURL=index.js.map\n","/*!\n * Source https://github.com/spielhalle/spielhalle Package: @spielhalle/client\n */\n/// <reference lib=\"webworker\" />\nimport { knuthSolveNum } from '@donmahallem/sudoku';\naddEventListener('message', (evt: MessageEvent): void => {\n    const results: number[][][] = knuthSolveNum(evt.data, 9, 3, 10);\n    self.postMessage(results);\n});\n"],"sourceRoot":"webpack:///"}